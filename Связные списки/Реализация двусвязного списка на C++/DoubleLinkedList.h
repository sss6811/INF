
// Created by sesab on 27.01.2024.

#ifndef DOUBLELINKEDLIST_DOUBLELINKEDLIST_H
#define DOUBLELINKEDLIST_DOUBLELINKEDLIST_H
#include <iostream> // ввод и вывод
#include <ctime> // для случайных чисел

template <typename T> // шаблонизация узла
class Node { // класс узла
public:
    T data; // значение, хранящееся в узле
    Node* prev;  // указатель на предыдущий узел
    Node* next; // указатель на следующий узел
    Node (T value) { // конструктор узла
        // инициализация узла переданными значениями
        data = value;
        prev = next = nullptr;
    }
};

template <typename T> // шаблонизация двусвязного списка
class DoubleLinkedList { // класс двусвязного списка
private:
    Node<T>* head; // указатель на начало списка 
    Node<T>* tail; // указатель на конец списка 
    size_t size; // размер списка
public:
    DoubleLinkedList() { // конструктор двусвязного списка
        head = tail = nullptr; // изначально указываю на nullptr
        size = 0; // изначально размер списка равен 0
    }

    void push_back(T val) { // метод добавления элемента в конец списка
        Node<T>* newNode = new Node<T>(val); // создание нового узла с переданным значением
        if (tail == nullptr) { // если список пуст
            head = tail = newNode; // новый узел будет и началом и концом
        } else { // если же в списке уже есть хотя бы один элемент
            newNode->prev = tail; // связываем новый узел с концом списка
            tail->next = newNode;
            tail = newNode; // сдвигаем указатель конца списка на новый узел
        }
        size++; // увеличиваем размер списка
    }

    void push_front(T val) { // метод добавления элемента в начало списка
        Node<T>* newNode = new Node<T>(val); // создание нового узла с переданным значением
        if (head == nullptr) { // если список пуст
            head = tail = newNode; // новый узел будет и началом и концом
        } else { // если же в списке уже есть хотя бы один элемент
            newNode->next = head; // связываем новый узел с началом списка
            head->prev = newNode; // сдвигаем указатель начала списка на новый узел
            head = newNode;
        }
        size++; // увеличиваем размер списка
    }

    void display() { // метод вывода на экран
        Node<T>* current = head; // начальный указатель - указательна на голову
        while (current) { // пока current не указывает на nullptr
            std::cout << current->data << " ";  // выводим значение узла, на который указывает current
            current = current->next; // переход к указателю на следующий узел следующему узлу
        }
        std::cout << std::endl;
    }

    void pop_front() {
        if (head) { // если список не пустой, то
            Node<T>* temp = head; // сохраняем указатель на удаляемый узел
            head = head->next; // переносим указатель на голову на следующий элемент
            if (head) { // если после удаления остался хотя бы один элемент
                head->prev = nullptr; // обновляем указатель на предыдущий, теперь он указывает на nullptr
            } else { // если мы удалили последний элемент
                tail = nullptr; // указатель на последний элемент теперь указывает на nullptr
            }
            delete temp; // удаляем сохраняемый узел
            size--; // уменьшаем размер списка
        }
    }

    void pop_back() {
        if (tail) { // если список не пустой
            Node<T>* temp = tail; // создаем указательна удаляемый узел
            tail = tail->prev; // переносим указатель на конец списка на предыдущий элемент
            if (tail) { // если после удаления остался хотя бы один элемент
                tail->next = nullptr; // обновляем указатель на следующий, теперь он указывает на nullptr
            } else { // если это был последний элемент
                head = nullptr; // то указатель на начало списка указывает на nullptr
            }
            delete temp; // удаляем сохраняемый узел
            size--; // уменьшаем размер списка
        }
    }

    void find_by_index(size_t index) {
        // мы используем тип size_t, чтобы избежать варнинга при сравнении индекса и размера списка
        if (index >= 0 && index < size) { // если введен "правильный" индекс, то создаем current пока что равный значению головы
            Node<T>* current = head;
            // т.к. index имеет тип size_t, то и для правильного сравнения мы будем использовать i c типом size_t
            for (size_t i = 0; i < index; i++) { // в цикле перебираем индексы элементов пока не дойдем до искомого индекса
                current = current->next; // присваиваем в current значение элемента под индексом i
            } // в конечном итоге значение current будет равно значению искомого элемента под введенным индексом
            std::cout << "Элемент с индексом " << index << " - это " << current->data << std::endl;
        } else { // если введен "неправильный" индекс, то создаем current пока что равный значению головы
            std::cout << "Элемент с индексом " << index << " не найден" << std::endl;
        }
    }

    int find_first_index(T value) { // метод для поиска индекса первого подходящего элемента по значению
        Node<T>* current = head; // наш первый элемент - голова (идем с право на лево)
        int index = 0; // 0 т.к. у нормальных людей индексация начинается с 0
        while (current) { // проходим по списку до тех пор, пока не найдем элемент с заданным значением
            if (current->data == value) { // если нашли, то возвращаем индекс
                return index;
            }
            current = current->next; // иначе сдвигаемся на следующий элемент
            index++; // и увеличиваем индекс на 1
        }
        // если введен элемент, которого не существует в списке
        return -1; // то возвращаем -1
    }

    int find_last_index(T value) { // метод для поиска индекса последнего подходящего элемента по значению
        Node<T>* current = tail; // наш первый элемент - голова (идем с лево на право)
        int index = size - 1; // Т.к. идем в обратном порядке
        // проходим по списку в обратном порядке до тех пор, пока не найдем элемент с заданным значением
        while (current) {  // проходим по списку до тех пор, пока не найдем элемент с заданным значением
            if (current->data == value) { // если нашли, то возвращаем индекс
                return index;
            }
            current = current->prev; // иначе сдвигаемся на предыдущий элемент
            index--; // и уменьшаем индекс на 1
        }
        // если введен элемент, которого не существует в списке
        return -1; // то возвращаем -1 
    }

    void insert_before_index(size_t index, T val) { // метод вставки элемента перед указанным индексом
        if (index >= 0 && index <= size) { // проверяем, что индекс находится в допустимом пределе
            Node<T>* newNode = new Node<T>(val); // создаем новый узел с переданным значением
            if (index == 0) { // если вставляем перед первым элементом (index == 0)
                push_front(val);
            } else { // если не перед первым элементом, то 
                // ищем узел с предыдущим индексом
                Node<T>* current = head; // сначала указатель current является указателем на первый элемент списка
                for (size_t i = 0; i < index - 1; i++) { // пока не дошли до индекса перед искомым 
                    current = current->next; // сдвигаем указатель на следующий узел
                }
                // связываем новый узел с предыдущим и следующим узлами
                newNode->prev = current;
                newNode->next = current->next;
                current->next->prev = newNode;
                current->next = newNode;
                size++; // увеличиваем размер списка
            }
        } else { // если не находятся в допустимом пределе, то выводим ошибку на экран
            std::cout << "Неверный индекс для вставки" << std::endl;
        }
    }

    void insert_after_index(size_t index, T val) { // метод для вставки элемента после указанного индекса
        if (index >= 0 && index < size) { // проверяем, что индекс находится в допустимом пределе
            Node<T>* newNode = new Node<T>(val); // создаем новый узел с переданным значением
            if (index == size - 1) { // если индекс равен размеру списка, вставляем в конец 
                push_back(val);
            } else {  // если не после последнего элемента, то
                // ищем узел с предыдущим индексом
                Node<T>* current = head; // сначала указатель current является указателем на первый элемент списка
                for (size_t i = 0; i < index; i++) { // пока не дошли до искомого индекса
                    current = current->next; // сдвигаем указатель на следующий узел
                }
                newNode->prev = current; // связываем новый узел с предыдущим и следующим узлами
                newNode->next = current->next;
                current->next->prev = newNode;
                current->next = newNode;
                size++; // увеличиваем размер списка
            }
        } else { // если не находятся в допустимом пределе, то выводим ошибку на экран
            std::cout << "Неверный индекс для вставки." << std::endl;
        }
    }

    void insert_before_value(T target, T newvalue) { // метод вставки элемента перед указанным значением
        int index = find_first_index(target); // ищем индекс первого вхождения указанного значения
        if (index != -1) { // если элемент с указанным значением найден, вставляем перед ним
            insert_before_index(static_cast<size_t>(index), newvalue);
            // static_cast<size_t>(index) используется для преобразования значения index из его текущего типа данных в тип данных size_t.
        } else { // если элемент не найден, выводим сообщение об ошибке
            std::cout << "Элемент с значением " << target << " не найден! Вставка невозможна" << std::endl;
        }
    }

    void insert_after_value(T target, T newvalue) { // метод вставки элемента после указанного значением
        int index = find_last_index(target); // ищем индекс последнего вхождения указанного значения
        if (index != -1) { // если элемент с указанным значением найден, вставляем после него
            insert_after_index(static_cast<size_t>(index), newvalue);
            // static_cast<size_t>(index) используется для преобразования значения index из его текущего типа данных в тип данных size_t.
        } else { // если элемент не найден, выводим сообщение об ошибке
            std::cout << "Элемент с значением " << target << " не найден! Вставка невозможна" << std::endl;
        }
    }

    void sort() { // алгоритм сортировки вставками
        if (size <= 1) { // если список содержит 1 элемент, то сортировать его не надо
            return;
        }
        Node<T>* sorted = nullptr; // указатель на начало отсортированного списка
        Node<T>* current = head; // указатель на текущий узел в исходном списке
        while (current) { // проходимся по всем узлам исходного списка
            Node<T>* next = current->next; // сохраняем указатель на следующий узел 
            if (!sorted || sorted->data >= current->data) { // проверка на вставку в начало списка
                // является ли sorted пустым (nullptr) или значение первого узла больше или равно значению текущего узла
                // устанавливаем предыдущий узел относительно текущего узла в nullptr, так как это будет начало списка
                current->prev = nullptr;
                // устанавливаем следующий узел относительно текущего узла в текущее начало отсортированного списка
                current->next = sorted;
                // если sorted не пуст, то устанавливаем предыдущий узел текущего начала отсортированного списка на текущий узел
                if (sorted) {
                    sorted->prev = current;
                }
                sorted = current; // обновляем указатель на начало отсортированного списка
            } else { // иначе мы будем производить вставку в конец или в другую область списка
                Node<T>* search = sorted;
                /* search->next - существует ли следующий узел в отсортированном списке
                search->next->data < current->data - меньше ли значение следующего узла, чем значение текущего узла
                если оба условия выполняются, то search переходит к следующему узлу в отсортированном списке*/
                while (search->next && search->next->data < current->data) {
                    search = search->next;
                    /*Цикл выполняется до тех пор, пока не будет найдено место,
                    куда следует вставить текущий узел. После этого current вставляется 
                    между узлом search и его следующим узлом*/
                }
                // соединяем текущий узел с предыдущим и следующим узлами в отсортированном списке
                current->prev = search;
                current->next = search->next;
                if (search->next) {
                    search->next->prev = current;
                }
                search->next = current;
            }
            current = next;
            head = sorted; tail = head; // обновляем указатели head и tail после сортировки
            while (tail->next) {
                tail = tail->next;
            }
        }
    }

    size_t getSize() const {
        return size;
    }

    ~DoubleLinkedList() { // деструктор
        Node<T>* current = head;
        while (current) {
            Node<T>* next = current->next;
            delete current;
            current = next;
        }
        head = tail = nullptr; // обнуляем указатели на начало и конец списка
        size = 0;
    }

};

#endif //DOUBLELINKEDLIST_DOUBLELINKEDLIST_H
